/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.22                          *
*        Compiled Jul  4 2013, 15:16:01                              *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
#include "includes.h"
#include  "app.h"
// USER END

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/


// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
extern __IO uint8_t key_flag;
extern KEY Key1,Key2;
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreateKEY[] = {
  { FRAMEWIN_CreateIndirect, "KEY", 0, 0, 0, 800, 480, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "KEY1", GUI_ID_BUTTON0, 200, 140, 150, 100, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "KEY2", GUI_ID_BUTTON1, 400, 140, 150, 100, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialogKEY(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId) 
  {
	  case WM_DELETE:
		// USER START (Optionally insert additional code for further widget initialization)
		    key_flag=1;
		    OS_DEBUG("KEYapp delete\n");
		    OnICON1 = 0;
			app_prevent_refresh = 0;
			LED1_OFF;LED2_OFF;
		// USER END
		    break;
	  case WM_INIT_DIALOG:
		//
		// Initialization of 'KEY TEST'
		//
		hItem = pMsg->hWin;
		FRAMEWIN_SetTitleHeight(hItem, 40);
		FRAMEWIN_SetTextColor(hItem,GUI_DARKGRAY);
		FRAMEWIN_SetFont(hItem, GUI_FONT_32B_ASCII);
		FRAMEWIN_AddCloseButton(hItem,FRAMEWIN_BUTTON_RIGHT,0);
	  
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0);
		BUTTON_SetFont(hItem, GUI_FONT_32B_ASCII);
	  
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON1);
		BUTTON_SetFont(hItem, GUI_FONT_32B_ASCII);
		
		// USER START (Optionally insert additional code for further widget initialization)
		key_flag=0;
		// USER END
		break;
	  case WM_NOTIFY_PARENT:
		Id    = WM_GetId(pMsg->hWinSrc);
		NCode = pMsg->Data.v;
		switch(Id) {
		case GUI_ID_BUTTON0: // Notifications sent by 'KEY1'
		  switch(NCode) {
		  case WM_NOTIFICATION_CLICKED:
			// USER START (Optionally insert code for reacting on notification message)
			LED1_ON;
			// USER END
			break;
		  case WM_NOTIFICATION_RELEASED:
			// USER START (Optionally insert code for reacting on notification message)
		    LED1_OFF;
			// USER END
			break;
		  case WM_NOTIFICATION_MOVED_OUT:
			// USER START (Optionally insert code for reacting on notification message)
			LED1_OFF;
			// USER END
			break;
		  // USER START (Optionally insert additional code for further notification handling)
		  // USER END
		  }
		  break;
		case GUI_ID_BUTTON1: // Notifications sent by 'KEY2'
		  switch(NCode) {
		  case WM_NOTIFICATION_CLICKED:
			// USER START (Optionally insert code for reacting on notification message)
			LED2_ON;
			// USER END
			break;
		  case WM_NOTIFICATION_RELEASED:
			// USER START (Optionally insert code for reacting on notification message)
			LED2_OFF;
			// USER END
			break;
		   case WM_NOTIFICATION_MOVED_OUT:
			// USER START (Optionally insert code for reacting on notification message)
			LED2_OFF;
			// USER END
			break;
		  // USER START (Optionally insert additional code for further notification handling)
		  // USER END
		  }
		  break;
		// USER START (Optionally insert additional code for further Ids)
		// USER END
		}
		break;
	  // USER START (Optionally insert additional message handling)
		case WM_PAINT:	
			GUI_SetBkColor(APPBKCOLOR);
			GUI_SetColor(GUI_MAGENTA);
			GUI_Clear();
			GUI_SetFont(&GUI_FontHZ32);
			GUI_DispStringHCenterAt("按键控制Led亮灭",400,35);
			GUI_DispStringHCenterAt("其他界面可用KEY2实现截图",400,70);
		break;
	  // USER END
	  default:
		WM_DefaultProc(pMsg);
		break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateKEY TEST
*/
void OnICON1Clicked(void)
{
	GUI_CreateDialogBox(_aDialogCreateKEY, GUI_COUNTOF(_aDialogCreateKEY), _cbDialogKEY, WM_HBKWIN, 0, 0);
	OS_DEBUG("KEYapp create\n");
	while(OnICON1)
	{					 				
		Key_RefreshState(&Key1);//刷新按键状态
		Key_RefreshState(&Key2);//刷新按键状态
		if(Key_AccessTimes(&Key1,KEY_ACCESS_READ)!=0 && !key_flag)//按键被按下过
		{
			LED1_TOGGLE;
			Key_AccessTimes(&Key1,KEY_ACCESS_WRITE_CLEAR);
		}
		if(Key_AccessTimes(&Key2,KEY_ACCESS_READ)!=0 && !key_flag)//按键被按下过
		{
			LED2_TOGGLE;
			Key_AccessTimes(&Key2,KEY_ACCESS_WRITE_CLEAR);
		}
		GUI_Delay(10); 				
	}
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
