/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.22                          *
*        Compiled Jul  4 2013, 15:16:01                              *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
#include "includes.h"
#include  "app.h"
// USER END

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/

// USER START (Optionally insert additional defines)
#define TXT_NAME_LEN 	50			//文件名长度，如果检测到文件名超过50 则丢弃这个文件 
#define NOTE_NUM        20
#define _DF1S	0x81
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
static WM_HWIN hname,hsave,hedit,hlist;
static uint8_t note_index=0;
static 	uint16_t messagesnote[2];
static char *txtBuffer=0;
static uint8_t  txtfile_num = 0;

extern FIL	file;							//文件句柄
extern FRESULT result;						//文件系统API函数返回值
extern UINT bw;			//已读或已写的字节数

/*********** 输入法 ********/
extern OS_TCB	AppTaskGuiKeyPadTCB;
extern uint8_t  keyflag;
extern WM_HWIN hKeyPad;
/*************************/

// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreateNote[] = {
  { FRAMEWIN_CreateIndirect, "Note", 0, 0, 0, 800, 480, 0, 0x0, 0 },
  { EDIT_CreateIndirect, "name", GUI_ID_EDIT0, 350, 3, 300,35, 0, 0x1e, 0 },
  { BUTTON_CreateIndirect, "save", GUI_ID_BUTTON0, 700, 3, 80, 35, 0, 0x0, 0 },
  { MULTIEDIT_CreateIndirect, "edit", GUI_ID_MULTIEDIT0, 300, 40, 790-300, 400-5, 0, 0x0, 0 },
  { LISTBOX_CreateIndirect, "Notelist", GUI_ID_LISTBOX0, 0, 0, 300-10, 440-5, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
static uint32_t  txt2buffer(char * sFilename) 
{
	OS_ERR      	err;
	txtBuffer = (char *)(0x680c0000);
	
	OSSchedLock(&err);	
	result = f_open(&file, sFilename, FA_READ);
	if (result != FR_OK)
	{
		OSSchedUnlock(&err);
		return 0;
	}
	//printf("filesize=%d\n",file.fsize);
	if(file.fsize>=1024*256)
	{
		printf("Note read fail!!!\n");
		OSSchedUnlock(&err);
		return 0;
  	}
	result = f_read(&file, txtBuffer, file.fsize, &bw);
	txtBuffer[file.fsize]='\0';
	if (result != FR_OK)
  	{
		OSSchedUnlock(&err);
		return 0;
  	}
	f_close(&file);
	OSSchedUnlock(&err);
	return bw;
	
}
/**
  * @brief  
  * @param  path:初始扫描路径
  * @retval result:文件系统的返回值
  */
static FRESULT scan_txtfiles (char* path) 
{ 
    FRESULT res; 		//部分在递归过程被修改的变量，不用全局变量	
    FILINFO fno; 
    DIR dir; 
    int i; 
    char *fn; 
	char file_name[TXT_NAME_LEN];	
	
#if _USE_LFN 
    static char lfn[_MAX_LFN * (_DF1S ? 2 : 1) + 1]; 	//长文件名支持
    fno.lfname = lfn; 
    fno.lfsize = sizeof(lfn); 
#endif 
	txtfile_num=0;
    res = f_opendir(&dir, path); //打开目录
    if (res == FR_OK) 
	{ 
        i = strlen(path); 
        for (;;) 
		{ 
            res = f_readdir(&dir, &fno); 										//读取目录下的内容
            if (res != FR_OK || fno.fname[0] == 0) break; 	//为空时表示所有项目读取完毕，跳出
#if _USE_LFN 
            fn = *fno.lfname ? fno.lfname : fno.fname; 
#else 
            fn = fno.fname; 
#endif 
            if (*fn == '.') continue; 											//点表示当前目录，跳过			
            if (fno.fattrib & AM_DIR) 
			{ 																							//目录，递归读取
                sprintf(&path[i], "/%s", fn); 							//合成完整目录名
                res = scan_txtfiles(path);											//递归遍历 
                if (res != FR_OK) 
					break; 																		//打开失败，跳出循环
                path[i] = 0; 
            } 
			else 
			{ 
				//printf("%s/%s\r\n", path, fn);								//输出文件名
				if(strstr(fn,".txt")||strstr(fn,".TXT"))
				{
					if (strlen(path)+strlen(fn)<TXT_NAME_LEN)
					{
						sprintf(file_name, "%s/%s", path, fn);
						LISTBOX_AddString(hlist,(const char*)file_name);
						txtfile_num++;//记录文件个数
						if(txtfile_num>=NOTE_NUM)break;
					}
				}//if mp3||wav
            }//else
        } //for
    } 
    return res; 
}
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialogNote(WM_MESSAGE * pMsg) {
	WM_HWIN hItem;
	int     NCode;
	int     Id;
	// USER START (Optionally insert additional variables)
	char newname[TXT_NAME_LEN]={0};
	char *txtpath="0:/Note";
	OS_ERR      err;
	// USER END

  switch (pMsg->MsgId) {
	  case WM_DELETE:
		OS_DEBUG("NOTEapp delete\n");
		OnICON12 = 0;
		WM_DeleteWindow(hname);
		WM_DeleteWindow(hedit);
		WM_DeleteWindow(hsave);
		WM_DeleteWindow(hlist);
		note_index=0;
		txtBuffer=0;
		app_prevent_refresh = 0;
		WM_DeleteWindow(hKeyPad);
	break;
  case WM_INIT_DIALOG:
    //
    // Initialization of 'Note'
    //
    hItem = pMsg->hWin;
    FRAMEWIN_SetTextColor(hItem,GUI_DARKGRAY);
    FRAMEWIN_SetFont(hItem, GUI_FONT_32B_ASCII);
    FRAMEWIN_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
	FRAMEWIN_AddCloseButton(hItem,FRAMEWIN_BUTTON_RIGHT,0);
    FRAMEWIN_SetTitleHeight(hItem, 40);
    //
    // Initialization of 'name'
    //
    hname = WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT0);
    EDIT_SetFont(hname, &GUI_FontHZ24);
	EDIT_EnableBlink(hname,500,1);
	EDIT_SetBkColor(hname,EDIT_CI_ENABLED,GUI_WHITE);
	EDIT_SetText(hname,"0:/Note/new.txt");
    //
    // Initialization of 'save'
    //
    hsave = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0);
    BUTTON_SetFont(hsave, GUI_FONT_24B_ASCII);
    //
    // Initialization of 'edit'
    //
    hedit = WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT0);
	MULTIEDIT_SetFont(hedit,&GUI_FontHZ24);
	MULTIEDIT_EnableBlink(hedit,500,1);
	MULTIEDIT_SetAutoScrollV(hedit,1);
	MULTIEDIT_SetInsertMode(hedit,1);
	//MULTIEDIT_SetReadOnly(hedit,1);
	MULTIEDIT_SetWrapWord(hedit);
	MULTIEDIT_SetBkColor(hedit,MULTIEDIT_CI_EDIT,APPBKCOLOR);
    //
    // Initialization of 'Notelist'
    //
    hlist = WM_GetDialogItem(pMsg->hWin, GUI_ID_LISTBOX0);
    LISTBOX_SetMulti(hlist,0);
    LISTBOX_SetFont(hlist, &GUI_FontHZ24);
	LISTBOX_SetAutoScrollV(hlist,1);
	LISTVIEW_SetBkColor(hlist,LISTVIEW_CI_SEL,APPBKCOLOR);
    // USER START (Optionally insert additional code for further widget initialization)
	scan_txtfiles(txtpath);
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case GUI_ID_EDIT0: // Notifications sent by 'name'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		messagesnote[0]=WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT0);
		messagesnote[1]=GUI_ID_EDIT0;
		if(!keyflag)OSTaskQPost(&AppTaskGuiKeyPadTCB,
					(void *)&messagesnote,
					2,
					OS_OPT_POST_FIFO,
					&err);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_BUTTON0: // Notifications sent by 'save'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
		if(MULTIEDIT_GetTextSize(hedit)>=1024*256)break;
		EDIT_GetText(hname,newname,40);
		result=f_open(&file,newname,  FA_CREATE_ALWAYS | FA_WRITE  );
		txtBuffer = (char *)(0x680c0000);		
		if ( result == FR_OK )
		{
			OSSchedLock(&err);
			MULTIEDIT_GetText(hedit,txtBuffer,MULTIEDIT_GetTextSize(hedit));
			result = f_write(&file, txtBuffer, MULTIEDIT_GetTextSize(hedit), &bw);
			//printf("filesize=%d,writesize=%d\n",k,bw);
			f_close(&file);
			OSSchedUnlock(&err);
		}
		txtBuffer =0;
		while(txtfile_num)
		{
			LISTBOX_DeleteItem(hlist,txtfile_num-1);
			txtfile_num--;
		}
		scan_txtfiles(txtpath);
		EDIT_SetText(hname,"0:/Note/new.txt");
		MULTIEDIT_SetText(hedit,'\0');
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_MULTIEDIT0: // Notifications sent by 'edit'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		messagesnote[0]=WM_GetDialogItem(pMsg->hWin, GUI_ID_MULTIEDIT0);
		messagesnote[1]=GUI_ID_MULTIEDIT0;
		if(!keyflag)OSTaskQPost(&AppTaskGuiKeyPadTCB,
					(void *)&messagesnote,
					2,
					OS_OPT_POST_FIFO,
					&err);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_LISTBOX0: // Notifications sent by 'Notelist'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
		note_index=LISTBOX_GetSel(hlist);
		LISTBOX_GetItemText(hlist,note_index,newname,TXT_NAME_LEN);
		WM_HasFocus(hname);
		EDIT_SetText(hname,(const char *)newname);
		
		txt2buffer((char *)newname);
		WM_HasFocus(hedit);
		MULTIEDIT_SetText(hedit,txtBuffer);
		// USER END
        break;
      case WM_NOTIFICATION_SEL_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateNote
*/
void OnICON12Clicked(void)
{
	OS_DEBUG("NOTEapp create\n");
	GUI_CreateDialogBox(_aDialogCreateNote, GUI_COUNTOF(_aDialogCreateNote), _cbDialogNote, WM_HBKWIN, 0, 0);
	while(OnICON12)
	{
		GUI_Delay(10); 
	}
}
// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/

