/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.22                          *
*        Compiled Jul  4 2013, 15:16:01                              *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
#include "includes.h"
#include  "app.h"
// USER END
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
// USER START (Optionally insert additional defines)
#define HIGH  1
#define LOW   0

#define DHT11_CLK     RCC_APB2Periph_GPIOB
#define DHT11_PIN     GPIO_Pin_10               
#define DHT11_PORT		GPIOB 

//带参宏，可以像内联函数一样使用,输出高电平或低电平
#define DHT11_DATA_OUT(a)	if (a)	\
					GPIO_SetBits(GPIOB,GPIO_Pin_10);\
					else		\
					GPIO_ResetBits(GPIOB,GPIO_Pin_10)
 //读取引脚的电平
#define  DHT11_DATA_IN()	   GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_10)
typedef struct
{
	uint8_t  humi_int;		//湿度的整数部分
	uint8_t  humi_deci;	 	//湿度的小数部分
	uint8_t  temp_int;	 	//温度的整数部分
	uint8_t  temp_deci;	 	//温度的小数部分
	uint8_t  check_sum;	 	//校验和
		                 
}DHT11_Data_TypeDef;
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
static DHT11_Data_TypeDef DHT11_Data;
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreateDHT11[] = {
  { FRAMEWIN_CreateIndirect, "DHT11",0, 0, 0, 800, 480, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "Data1",  GUI_ID_TEXT1, 300, 150, 100, 35, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "Unit1",  GUI_ID_TEXT2, 400, 152, 100, 35, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "Data2",  GUI_ID_TEXT4, 300, 250, 100, 35, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "Unit2", GUI_ID_TEXT5,  400, 250, 100, 35, 0, 0x64, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/
// USER START (Optionally insert additional static code)
/*
 * 函数名：DHT11_GPIO_Config
 * 描述  ：配置DHT11用到的I/O口
 * 输入  ：无
 * 输出  ：无
 */
void DHT11_GPIO_Config(void)
{		
	/*定义一个GPIO_InitTypeDef类型的结构体*/
	GPIO_InitTypeDef GPIO_InitStructure;

	/*开启DHT11_PORT的外设时钟*/
	RCC_APB2PeriphClockCmd(DHT11_CLK, ENABLE); 

	/*选择要控制的DHT11_PORT引脚*/															   
  	GPIO_InitStructure.GPIO_Pin = DHT11_PIN;	

	/*设置引脚模式为通用推挽输出*/
  	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   

	/*设置引脚速率为50MHz */   
  	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 

	/*调用库函数，初始化DHT11_PORT*/
  	GPIO_Init(DHT11_PORT, &GPIO_InitStructure);		  

	/* 拉高GPIOB10	*/
	GPIO_SetBits(DHT11_PORT, GPIO_Pin_10);	 
}

/*
 * 函数名：DHT11_Mode_IPU
 * 描述  ：使DHT11-DATA引脚变为上拉输入模式
 * 输入  ：无
 * 输出  ：无
 */
static void DHT11_Mode_IPU(void)
{
 	  GPIO_InitTypeDef GPIO_InitStructure;

	  	/*选择要控制的DHT11_PORT引脚*/	
	  GPIO_InitStructure.GPIO_Pin = DHT11_PIN;

	   /*设置引脚模式为浮空输入模式*/ 
	  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU ; 

	  /*调用库函数，初始化DHT11_PORT*/
	  GPIO_Init(DHT11_PORT, &GPIO_InitStructure);	 
}

/*
 * 函数名：DHT11_Mode_Out_PP
 * 描述  ：使DHT11-DATA引脚变为推挽输出模式
 * 输入  ：无
 * 输出  ：无
 */
static void DHT11_Mode_Out_PP(void)
{
 	GPIO_InitTypeDef GPIO_InitStructure;

	 	/*选择要控制的DHT11_PORT引脚*/															   
  	GPIO_InitStructure.GPIO_Pin = DHT11_PIN;	

	/*设置引脚模式为通用推挽输出*/
  	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   

	/*设置引脚速率为50MHz */   
  	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	/*调用库函数，初始化DHT11_PORT*/
  	GPIO_Init(DHT11_PORT, &GPIO_InitStructure);	 	 
}

/* 
 * 从DHT11读取一个字节，MSB先行
 */
static uint8_t Read_Byte(void)
{
	uint8_t i, temp=0;

	for(i=0;i<8;i++)    
	{	 
		/*每bit以50us低电平标置开始，轮询直到从机发出 的50us 低电平 结束*/  
		while(DHT11_DATA_IN()==Bit_RESET);

		/*DHT11 以26~28us的高电平表示“0”，以70us高电平表示“1”，
		 *通过检测 x us后的电平即可区别这两个状 ，x 即下面的延时 
		 */
		bsp_DelayUS(40); //延时x us 这个延时需要大于数据0持续的时间即可	   	  

		if(DHT11_DATA_IN()==Bit_SET)/* x us后仍为高电平表示数据“1” */
		{
			/* 等待数据1的高电平结束 */
			while(DHT11_DATA_IN()==Bit_SET);

			temp|=(uint8_t)(0x01<<(7-i));  //把第7-i位置1，MSB先行 
		}
		else	 // x us后为低电平表示数据“0”
		{			   
			temp&=(uint8_t)~(0x01<<(7-i)); //把第7-i位置0，MSB先行
		}
	}
	return temp;
}
/*
 * 一次完整的数据传输为40bit，高位先出
 * 8bit 湿度整数 + 8bit 湿度小数 + 8bit 温度整数 + 8bit 温度小数 + 8bit 校验和 
 */
uint8_t Read_DHT11(DHT11_Data_TypeDef *DHT11_Data)
{  
	/*输出模式*/
	DHT11_Mode_Out_PP();
	/*主机拉低*/
	DHT11_DATA_OUT(LOW);
	/*延时18ms*/
	bsp_DelayUS(18000);

	/*总线拉高 主机延时30us*/
	DHT11_DATA_OUT(HIGH); 

	bsp_DelayUS(30);   //延时30us

	/*主机设为输入 判断从机响应信号*/ 
	DHT11_Mode_IPU();

	/*判断从机是否有低电平响应信号 如不响应则跳出，响应则向下运行*/   
	if(DHT11_DATA_IN()==Bit_RESET)     
	{
		/*轮询直到从机发出 的80us 低电平 响应信号结束*/  
		while(DHT11_DATA_IN()==Bit_RESET);

		/*轮询直到从机发出的 80us 高电平 标置信号结束*/
		while(DHT11_DATA_IN()==Bit_SET);
		/*开始接收数据*/   
		DHT11_Data->humi_int= Read_Byte();

		DHT11_Data->humi_deci= Read_Byte();

		DHT11_Data->temp_int= Read_Byte();

		DHT11_Data->temp_deci= Read_Byte();

		DHT11_Data->check_sum= Read_Byte();

		/*读取结束，引脚改为输出模式*/
		DHT11_Mode_Out_PP();
		/*主机拉高*/
		DHT11_DATA_OUT(HIGH);

		/*检查读取的数据是否正确*/
		if(DHT11_Data->check_sum == DHT11_Data->humi_int + DHT11_Data->humi_deci + DHT11_Data->temp_int+ DHT11_Data->temp_deci)
			return SUCCESS;
		else 
			return ERROR;
	}
	else
	{		
		return ERROR;
	}   
}
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialogDHT11(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId){
	    case WM_DELETE:
		OS_DEBUG("DHT11app delete\n");
		OnICON7 = 0;
		//RCC_APB2PeriphClockCmd(DHT11_CLK, DISABLE); 
		app_prevent_refresh = 0;
		break;
  case WM_INIT_DIALOG:
    //
    // Initialization of 'DHT11'
    //
    hItem = pMsg->hWin;
	FRAMEWIN_SetTextColor(hItem,GUI_DARKGRAY);
    FRAMEWIN_SetFont(hItem, GUI_FONT_32B_ASCII);
    FRAMEWIN_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
	FRAMEWIN_AddCloseButton(hItem,FRAMEWIN_BUTTON_RIGHT,0);
    FRAMEWIN_SetTitleHeight(hItem, 40);
//    //
//    // Initialization of 'Temp'
//    //
//    hItem = WM_GetDialogItem(pMsg->hWin,  GUI_ID_TEXT0);
//    TEXT_SetFont(hItem, GUI_FONT_20B_ASCII);
//    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
//    TEXT_SetText(hItem, "Temperature");
    //
    // Initialization of 'Data1'
    //
    hItem = WM_GetDialogItem(pMsg->hWin,  GUI_ID_TEXT1);
    TEXT_SetFont(hItem, GUI_FONT_32B_ASCII);
    TEXT_SetText(hItem, "****");
    TEXT_SetTextColor(hItem, 0x00FF0000);
    TEXT_SetTextAlign(hItem, GUI_TA_RIGHT | GUI_TA_VCENTER);
    //
    // Initialization of 'Unit1'
    //
    hItem = WM_GetDialogItem(pMsg->hWin,  GUI_ID_TEXT2);
    TEXT_SetFont(hItem, &GUI_FontHZ32);
    TEXT_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "度");
//    //
//    // Initialization of 'Humidity'
//    //
//    hItem = WM_GetDialogItem(pMsg->hWin,  GUI_ID_TEXT3);
//    TEXT_SetFont(hItem, GUI_FONT_20B_ASCII);
//    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    //
    // Initialization of 'Data2'
    //
    hItem = WM_GetDialogItem(pMsg->hWin,  GUI_ID_TEXT4);
    TEXT_SetFont(hItem, GUI_FONT_32B_ASCII);
    TEXT_SetText(hItem, "****");
    TEXT_SetTextAlign(hItem, GUI_TA_RIGHT | GUI_TA_VCENTER);
    TEXT_SetTextColor(hItem, 0x00FF0000);
    //
    // Initialization of 'Unit2'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT5);
    TEXT_SetFont(hItem, GUI_FONT_32B_ASCII);
    TEXT_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "RH");
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  // USER START (Optionally insert additional message handling)
     case WM_PAINT:	
		GUI_SetBkColor(APPBKCOLOR);
		GUI_SetColor(APPTEXTCOLOR);
		GUI_Clear();
		GUI_SetFont(&GUI_FontHZ32);
		GUI_DispStringHCenterAt("DHT11温湿度读取",400,10);
		GUI_DispStringHCenterAt("保证将DHT11插在卡槽中",400,50);
		GUI_DispStringHCenterAt("温度值",400,100);
		GUI_DispStringHCenterAt("湿度值",400,200);
		break;
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateDHT11
*/
void OnICON7Clicked(void) 
{
	WM_HWIN hWin;
	uint8_t i=0;
	OS_ERR      err;
	char text1[6]={0},text2[6]={0};
	OS_DEBUG("DHT11app create\n");
	/*初始化DTT11的引脚*/
	DHT11_GPIO_Config();
	hWin = GUI_CreateDialogBox(_aDialogCreateDHT11, GUI_COUNTOF(_aDialogCreateDHT11), _cbDialogDHT11, WM_HBKWIN, 0, 0);
	while(OnICON7)
	{
		i++;
		if(i>=150)
		{
			OSSchedLock(&err);
			/*调用Read_DHT11读取温湿度，若成功则输出该信息*/
			if(Read_DHT11(&DHT11_Data)==SUCCESS)
			{
				sprintf(text1,"%d.%d",DHT11_Data.temp_int,DHT11_Data.temp_deci);
				TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT1),text1);
				TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT2),"度");
				sprintf(text2,"%d.%d",DHT11_Data.humi_int,DHT11_Data.humi_deci);
				TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT4),text2);
				TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT5),"RH");
			}
			else
			{
				TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT1),"error");
				TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT2),"");
				TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT4),"error");
				TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT5),"");
			}
			OSSchedUnlock(&err);
			i=0;
		}
		GUI_Delay(10);
	}
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
