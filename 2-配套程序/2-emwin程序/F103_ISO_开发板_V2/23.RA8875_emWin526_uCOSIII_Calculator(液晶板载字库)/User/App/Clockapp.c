/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.22                          *
*        Compiled Jul  4 2013, 15:16:01                              *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
#include "includes.h"
#include  "app.h"
// USER END

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
extern char TimeDisplay;
static	char text_buffer[30];
static 	uint16_t messagesclock[2];
static 	struct rtc_time SrcTm;
/*时间结构体*/
extern struct rtc_time systmtime;

/*-------- 输入法 ----------*/
extern OS_TCB	AppTaskGuiKeyPadTCB;
extern uint8_t  keyflag;
extern WM_HWIN hKeyPad;
/*--------------------------*/

// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreateClock[] = {
  { FRAMEWIN_CreateIndirect, "Clock", 0, 0, 0, 800, 480, WM_CF_MEMDEV, 0x64, 0 },
  { TEXT_CreateIndirect, "Time", GUI_ID_TEXT3, 100, 370, 200, 50, WM_CF_MEMDEV, 0x64, 0 },
  { TEXT_CreateIndirect, "wday", GUI_ID_TEXT1, 400, 350, 200, 30, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "Data", GUI_ID_TEXT2, 400, 380, 200, 50, 0, 0x64, 0 },

  { BUTTON_CreateIndirect, "Ok", GUI_ID_BUTTON0, 325, 220, 150, 75, 0, 0x0, 0 },

  { EDIT_CreateIndirect, "Year", GUI_ID_EDIT0,  150,  75, 100, 40, 0, 0x4, 0 },
  { EDIT_CreateIndirect, "Month", GUI_ID_EDIT1, 350, 75, 100, 40, 0, 0x2, 0 },
  { EDIT_CreateIndirect, "Day", GUI_ID_EDIT2,   550, 75, 100, 40, 0, 0x2, 0 },

  { EDIT_CreateIndirect, "HOUR", GUI_ID_EDIT3,   150,  155, 100, 40, 0, 0x2, 0 },
  { EDIT_CreateIndirect, "Minute", GUI_ID_EDIT4, 350, 155, 100, 40, 0, 0x2, 0 },
  { EDIT_CreateIndirect, "Edit", GUI_ID_EDIT5,   550, 155, 100, 40, 0, 0x2, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialogClock(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
  OS_ERR      err;
  // USER END

  switch (pMsg->MsgId) {
	case WM_TIMER:
		//printf("Clockapp:MY_MESSAGE_RTC\n");
		if(!TimeDisplay)
		{
			WM_RestartTimer(pMsg->Data.v, 1000);
			break;
		}
		/* 转换rtc值至北京时间*/
		RTC_TimeCovr(&systmtime);
	
		/* 转换成字符串 */
		sprintf(text_buffer,"%04d.%02d.%02d",systmtime.tm_year,systmtime.tm_mon,systmtime.tm_mday);
		
		/* 获取text句柄 */
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT2);//2015.04.28
		
		/* 输出时间 */
		TEXT_SetText(hItem,text_buffer);
		
		/* 获取text句柄 */
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT1);//Wednesday
		
		/* 输出星期 */
		switch(systmtime.tm_wday)
		{
			case 1:
			/* 输出时间 */
			TEXT_SetText(hItem,"Monday");				
			break;
		
			case 2:
			/* 输出时间 */
			TEXT_SetText(hItem,"Tuesday");				
			break;
								
			case 3:
			/* 输出时间 */
			TEXT_SetText(hItem,"Wednesday");				
			break;
											
			case 4:
			/* 输出时间 */
			TEXT_SetText(hItem,"Thursday");				
			break;
			
			case 5:
			/* 输出时间 */
			TEXT_SetText(hItem,"Friday");				
			break;
														
			case 6:
			/* 输出时间 */
			TEXT_SetText(hItem,"Saturday");				
			break;			
			
			case 7:
			/* 输出时间 */
			TEXT_SetText(hItem,"Sunday");				
			break;
		
			default:
			  break;
		}
		/* 转换成字符串 */
		sprintf(text_buffer,"%02d:%02d:%02d",systmtime.tm_hour,systmtime.tm_min,systmtime.tm_sec);
		//printf("time:%s\n",text_buffer);
		/* 获取text句柄 */
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT3);//00:00:00
		/* 输出时间 */
		TEXT_SetText(hItem,text_buffer);
		WM_RestartTimer(pMsg->Data.v, 1000);
	break;
  case WM_DELETE:
	OS_DEBUG("Clockapp delete\n");	
	WM_DeleteWindow(hKeyPad);
	app_prevent_refresh = 0;
	OnICON9 = 0;
	break;
  case WM_INIT_DIALOG:
    //
    // Initialization of 'Clock'
    //
    hItem = pMsg->hWin;
	FRAMEWIN_SetTextColor(hItem,GUI_DARKGRAY);
    FRAMEWIN_SetFont(hItem, GUI_FONT_32B_ASCII);
    FRAMEWIN_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
	FRAMEWIN_AddCloseButton(hItem,FRAMEWIN_BUTTON_RIGHT,0);
    FRAMEWIN_SetTitleHeight(hItem, 40);
    //
    // Initialization of 'Time'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT3);
    TEXT_SetFont(hItem, GUI_FONT_32B_ASCII);
    TEXT_SetText(hItem, "00:00:00");
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    //
    // Initialization of 'wday'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT1);
    TEXT_SetFont(hItem, GUI_FONT_24B_ASCII);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "Sunday");
    //
    // Initialization of 'Data'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT2);
    TEXT_SetFont(hItem, GUI_FONT_32B_ASCII);
    TEXT_SetText(hItem, "2001.01.01");
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
	
    //
    // Initialization of 'Ok'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_BUTTON0);
    BUTTON_SetFont(hItem, &GUI_FontHZ32);
    BUTTON_SetText(hItem, "设置时间");
	BUTTON_SetFocussable(hItem, 0);

    //
    // Initialization of 'Year'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT0);
    EDIT_SetText(hItem, "2015");
    EDIT_SetFont(hItem, GUI_FONT_32_ASCII);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
	EDIT_SetUlongMode(hItem,2015,1970,2038);
    //
    // Initialization of 'Month'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT1);
    EDIT_SetText(hItem, "04");
    EDIT_SetFont(hItem, GUI_FONT_32B_ASCII);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
	EDIT_SetUlongMode(hItem,04,1,12);
    //
    // Initialization of 'Day'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT2);
    EDIT_SetText(hItem, "28");
    EDIT_SetFont(hItem, GUI_FONT_32B_ASCII);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
	EDIT_SetUlongMode(hItem,28,1,31);

    //
    // Initialization of 'HOUR'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT3);
    EDIT_SetText(hItem, "11");
    EDIT_SetFont(hItem, GUI_FONT_32B_ASCII);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
	EDIT_SetUlongMode(hItem,11,0,23);
    //
    // Initialization of 'Minute'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT4);
    EDIT_SetText(hItem, "55");
    EDIT_SetFont(hItem, GUI_FONT_32B_ASCII);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
	EDIT_SetUlongMode(hItem,55,0,59);
    //
    // Initialization of 'Edit'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT5);
    EDIT_SetText(hItem, "55");
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    EDIT_SetFont(hItem, GUI_FONT_32B_ASCII);
	EDIT_SetUlongMode(hItem,55,0,59);
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case GUI_ID_BUTTON0: // Notifications sent by 'Ok'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
		SrcTm.tm_year  = EDIT_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT0));
		SrcTm.tm_mon  = EDIT_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT1));
		SrcTm.tm_mday = EDIT_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT2));
		SrcTm.tm_hour = EDIT_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT3));
		SrcTm.tm_min = EDIT_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT4));
		SrcTm.tm_sec = EDIT_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT5));
		
		Time_Adjust_LCD(&systmtime,&SrcTm);
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_EDIT0: // Notifications sent by 'Year'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		messagesclock[0]=WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT0);
		messagesclock[1]=GUI_ID_EDIT0;
		if(!keyflag)OSTaskQPost(&AppTaskGuiKeyPadTCB,
					(void *)&messagesclock,
					2,
					OS_OPT_POST_FIFO,
					&err);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_EDIT1: // Notifications sent by 'Month'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		messagesclock[0]=WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT1);
		messagesclock[1]=GUI_ID_EDIT1;
		if(!keyflag)OSTaskQPost(&AppTaskGuiKeyPadTCB,
					(void *)&messagesclock,
					2,
					OS_OPT_POST_FIFO,
					&err);
	  
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_EDIT2: // Notifications sent by 'Day'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		messagesclock[0]=WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT2);
		messagesclock[1]=GUI_ID_EDIT2;
		if(!keyflag)OSTaskQPost(&AppTaskGuiKeyPadTCB,
					(void *)&messagesclock,
					2,
					OS_OPT_POST_FIFO,
					&err);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_EDIT3: // Notifications sent by 'HOUR'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		messagesclock[0]=WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT3);
		messagesclock[1]=GUI_ID_EDIT3;
		if(!keyflag)OSTaskQPost(&AppTaskGuiKeyPadTCB,
					(void *)&messagesclock,
					2,
					OS_OPT_POST_FIFO,
					&err);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_EDIT4: // Notifications sent by 'Minute'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		messagesclock[0]=WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT4);
		messagesclock[1]=GUI_ID_EDIT4;
		if(!keyflag)OSTaskQPost(&AppTaskGuiKeyPadTCB,
					(void *)&messagesclock,
					2,
					OS_OPT_POST_FIFO,
					&err);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_EDIT5: // Notifications sent by 'Edit'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
		messagesclock[0]=WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT5);
		messagesclock[1]=GUI_ID_EDIT5;
		if(!keyflag)OSTaskQPost(&AppTaskGuiKeyPadTCB,
					(void *)&messagesclock,
					2,
					OS_OPT_POST_FIFO,
					&err);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
	case WM_PAINT:                                            //重绘背景	
    GUI_SetBkColor(APPBKCOLOR);
	GUI_SetColor(APPTEXTCOLOR);
	GUI_Clear();
	GUI_SetFont(&GUI_FontHZ32);
	GUI_DispStringHCenterAt("时间设置:",200,5);
	GUI_DispStringHCenterAt("年          月          日",400,40);
	GUI_DispStringHCenterAt("时          分          秒",400,120);
    break;
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateClock
*/
void OnICON9Clicked(void)
{
	WM_HWIN hWin;
	OS_DEBUG("Clockapp create\n");
	hWin = GUI_CreateDialogBox(_aDialogCreateClock, GUI_COUNTOF(_aDialogCreateClock), _cbDialogClock, WM_HBKWIN, 0, 0);

	/* 
	 * 创建定时器，其功能是经过指定周期后，向指定窗口发送消息。
	 * 该定时器与指定窗口相关联。 
	 */
	WM_CreateTimer(WM_GetClientWindow(hWin),  /* 接受信息的窗口的句柄 */
	               0, 	         /* 用户定义的Id。如果不对同一窗口使用多个定时器，此值可以设置为零。 */
				   1000,         /* 周期，此周期过后指定窗口应收到消息*/
				   0);	         /* 留待将来使用，应为0 */
	while(OnICON9)
	{
		GUI_Delay(10); 
	}
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
